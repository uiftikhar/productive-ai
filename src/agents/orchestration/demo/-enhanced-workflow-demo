// import { EnhancedWorkflowExecutorService } from '../enhanced-workflow-executor.service.ts';
// import { AgentRegistryService } from '../../services/agent-registry.service.ts';
// import { KnowledgeRetrievalAgent } from '../../specialized/knowledge-retrieval-agent.ts';
// import { AgentDiscoveryService } from '../../services/agent-discovery.service.ts';
// import { CommunicationBusService } from '../../messaging/communication-bus.service.ts';
// import { MessageType } from '../../messaging/agent-message.interface.ts';
// import { ConsoleLogger } from '../../../shared/logger/console-logger.ts';

// /**
//  * A demo script showcasing the enhanced workflow executor with agent discovery and messaging
//  */
// async function runEnhancedWorkflowDemo() {
//   const logger = new ConsoleLogger();
//   logger.setLogLevel('debug');
  
//   // Initialize services
//   const registry = AgentRegistryService.getInstance();
//   const discovery = AgentDiscoveryService.getInstance();
//   const communicationBus = CommunicationBusService.getInstance();
  
//   // Initialize workflow executor
//   const workflowExecutor = EnhancedWorkflowExecutorService.getInstance({
//     logger,
//     registry,
//     discovery,
//     communicationBus
//   });
  
//   // Register the knowledge retrieval agent
//   try {
//     const knowledgeAgent = new KnowledgeRetrievalAgent();
//     await registry.registerAgent(knowledgeAgent);
//     logger.info('Registered Knowledge Retrieval Agent');
//   } catch (error) {
//     logger.debug('Knowledge Retrieval Agent already registered or failed to register', {
//       error: error instanceof Error ? error.message : String(error)
//     });
//   }
  
//   // Register model selection capability
//   registry.registerAgent({
//     id: 'model-selector',
//     name: 'Model Selector Agent',
//     description: 'Selects the most appropriate model for processing based on query complexity',
//     capabilities: ['select_model'],
//     // async execute(input, context) {
//     //   logger.info('Model Selector Agent executing', { input });
      
//     //   // Analyze the query and knowledge to select a model
//     //   const inputData = typeof input === 'string' ? input : JSON.stringify(input);
//     //   const knowledgeContent = context.variables.knowledgeContent || [];
      
//     //   // Simulate model selection logic
//     //   const queryComplexity = inputData.length > 100 ? 'high' : 'medium';
//     //   const hasSpecializedKnowledge = knowledgeContent.length > 2;
      
//     //   // Select model based on complexity and available knowledge
//     //   let selectedModel;
//     //   if (queryComplexity === 'high' && hasSpecializedKnowledge) {
//     //     selectedModel = 'gpt-4';
//     //   } else if (queryComplexity === 'high') {
//     //     selectedModel = 'claude-3-opus';
//     //   } else {
//     //     selectedModel = 'claude-3-haiku';
//     //   }
      
//     //   return {
//     //     success: true,
//     //     output: JSON.stringify({
//     //       selectedModel,
//     //       reasoning: `Selected ${selectedModel} based on ${queryComplexity} complexity and ${hasSpecializedKnowledge ? 'specialized' : 'general'} knowledge requirements.`
//     //     })
//     //   };
//     // }
//   });
  
//   // Register response generation capability
// //   registry.registerAgent({
// //     id: 'response-generator',
// //     name: 'Response Generator Agent',
// //     description: 'Generates responses using the selected model and retrieved knowledge',
// //     capabilities: ['generate_response'],
// //     async execute(input, context) {
// //       logger.info('Response Generator Agent executing', { input });
      
// //       const selectedModel = context.variables.selectedModel || 'claude-3-haiku';
// //       const knowledgeContent = context.variables.knowledgeContent || [];
      
// //       // In a real implementation, we would use the model router to call the selected model
// //       // For this demo, we'll simulate the response
      
// //       const response = `This is a simulated response using ${selectedModel} model.
// // Based on the retrieved knowledge (${knowledgeContent.length} items), I can provide the following answer:
      
// // The question was about "${context.input}".
      
// // In a production system, this would be generated by the actual AI model using the retrieved knowledge.`;
      
// //       // If streaming is enabled, simulate token streaming
// //       if (context.variables.streamingHandler) {
// //         const tokens = response.split(' ');
// //         for (const token of tokens) {
// //           context.variables.streamingHandler.handleNewToken(token + ' ');
// //           // Add a small delay to simulate streaming
// //           await new Promise(resolve => setTimeout(resolve, 50));
// //         }
// //         context.variables.streamingHandler.handleComplete(response);
// //       }
      
// //       return {
// //         success: true,
// //         output: response
// //       };
// //     }
// //   });
  
//   // Set up message subscription to monitor all messages
//   const subscriptionId = communicationBus.subscribe(
//     { }, // Subscribe to all messages
//     (message) => {
//       logger.debug('Message received', {
//         type: message.type,
//         source: message.sourceId,
//         target: message.targetId || 'broadcast',
//         topic: message.metadata?.topic
//       });
//     }
//   );
  
//   // Create a workflow definition
//   const workflowDefinition = workflowExecutor.createAdaptiveQueryWorkflow();
  
//   // Execute the workflow
//   logger.info('Starting the Enhanced Workflow Demo');
//   logger.info('-'.repeat(50));
  
//   const result = await workflowExecutor.executeWorkflow(
//     workflowDefinition,
//     'What is the relationship between quantum mechanics and general relativity?',
//     {
//       userId: 'demo-user-123',
//       conversationId: 'demo-conversation-456',
//       streamingCallback: (token) => {
//         // Print each token to the console to show streaming
//         process.stdout.write(token);
//       },
//       discoveryOptions: {
//         performanceWeight: 0.7,
//         reliabilityWeight: 0.3
//       }
//     }
//   );
  
//   logger.info('\n' + '-'.repeat(50));
//   logger.info('Workflow execution completed', {
//     executionTime: result.metrics.totalExecutionTimeMs,
//     stepCount: result.steps.length
//   });
  
//   // Display step details
//   logger.info('Step execution details:');
//   result.steps.forEach(step => {
//     logger.info(`- ${step.name}`, {
//       status: step.status,
//       executionTime: step.executionTimeMs
//     });
//   });
  
//   // Display message summary
//   const messageTypes = result.messages.reduce((acc, message) => {
//     const type = message.type || 'UNKNOWN';
//     acc[type] = (acc[type] || 0) + 1;
//     return acc;
//   }, {} as Record<string, number>);
  
//   logger.info('Message summary:', messageTypes);
  
//   // Clean up
//   communicationBus.unsubscribe(subscriptionId);
  
//   logger.info('Enhanced Workflow Demo completed');
// }

// // Run the demo
// runEnhancedWorkflowDemo().catch(error => {
//   console.error('Error running Enhanced Workflow Demo:', error);
//   process.exit(1);
// }); 